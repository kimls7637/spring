<details>
<summary>세팅 및 에러</summary>
<div markdown="1">       

1. 프로젝트 우클릭 > Properties > Maven > Project Facets
	Java 현재 버전으로 맞추기
	Dynamic Web Module 2.5
	Runtimes Apache Tomcat v9.0
2. 프로젝트 우클릭 > Properties  > Java Build Path > Server Runtime [Apache Tomcat v9.0] 있는지 확인
3. META-INF 삭제
4. webapp > web.xml 중간내용 다 삭제
5. webapp > WEB-INF > spring, view 삭제
6. pom.xml > java버전 맞추기, 4.2.4.RELEASE

1. An error has occurred, See error log for more details. 'boolean com/ibm.icu.text.UTF16.isSurrogate(Char)'
 window > preferences > java > Editor > mark occurrences 체크박스 풀기

2. log4j.xml 빨간줄
<!DOCTYPE log4j:configuration SYSTEM "http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd">
두번째줄 이걸로 변경하기

3. web.xml 빨간줄
아무거나 썼다 지우기

자바 버전 11
이클립스 21년 12월 이전

</div>
</details>
<details>
<summary>0206</summary>
<div markdown="1">       

*Spring 프레임워크
처음 수업 때 구조적인 것을 많이 알려드릴 예정

*워크스페이스 하나 더만들어서 진행
파일 > 스위치 워크스페이스
윈도우 > 프리퍼런스
	웹 > jsp, html, css > utf8
	제네럴 > 웹브라우저 > 크롬
	워크스페이스 > utf8

----------

*프레임워크
개발을 어떻게 해야하는지 아웃라인을 제공
개발을 어떻게 하는 것이 좋은가? 유지보수가 용이하게
	MVC 디자인 패턴 : 결합도 낮추고 응집도 높임
		M : VO, 인자
		C : FC, AF, A 활용
		고정적으로 사용하는 것들
우리는 구조를 배워나갈 예정
물론 어떻게 쓰는지도 배울 것

*왜 사용하나요?
	1) 개발시간 단축, 개발비용 절감
	2) 관리가 용이 == 유지보수 용이 << 개발의 최상위 목표
	3) 개발자들의 실력이 상향 평준화
"IoC와 AOP를 지원하는 경량(POJO를 다를 수 있다는 의미)의 프레임워크"
개념 설명 --> 코드 --> 개념 설명

*Ioc (Inversion of Control) 제어의 역행 / 우리에게서 new를 가져갔다
fav.do 요청
-> new FavAction(req,res); : FC에서 작성된 코드
== 개발자가 직접 new를 작성
== 객체화를 담당해주는 주체는 아직 없는 상황
== 객체가 언제 만들어지고, 언제 사용되는지에 대한(객체 생명주기) 관리가 개발자에게 달려있는 상황
== 결합도가 높아짐 : Spring 프레임워크에서는 "new"가 적을수록 좋은코드!
	지금 이 액션류들이 최대한 변화되는 것을 방지하기 위해 인터페이를 사용 
	그래도 바뀔 수 있음 틀리면 빨간밑줄 그럼 컴파일 자체가 안됨
	FC가 안돌아간다는 것은 시스템 자체가 먹통이 된다는 소리 가용성이 떨어짐

*new 없이 객체화를 어떻게 하나요?
	: FrontController
		서블릿(.java, not POJO)
		어노테이션도 달려있고 임포트도 달려있지만 클래스의 한 종류라서 .java로 끝남
		서블릿 객체를 관리해주는 "서블릿 컨테이너" == 톰캣 == 웹 서버, 서버
		서블릿 컨테이너는 객체화를 담당함
	: EncFilter
		필터 클래스(.java, not POJO, 필터 자체가 서블릿을 상속받은 클래스)
		*.do 요청에 의해 자동으로 doFIlter()가 수행되었었음!
		서블릿 컨테이너는 객체화도 담당하지만, 단순 메서드 호출도 관리할 수 있음
	: Listener
		마찬가지
서블릿들을 자동 관리해주는 서블릿 컨테이너 역할을 아팟치 톰캣이 담당하고 있기 때문에
> 컨테이너는 객체 생성(객체화) 및 객체 사용(메서드 호출)을 관리할 수 있음
소스코드에 new가 없어짐 -> 결합도가 낮아짐 -> 유지보수 용이
언제 new 해야하는 지에 대한 "설정정보"가 필요함
== 의존관계(dependency)를 명시해야함
POJO(일반 자바 객체)들도 객체화해줄 수 있는 Spring 프레임워크!
	서블릿을 관리해주는 친구를 서블릿 컨테이너라고 함(톰캣)
	일반 자바 객체들을 관리해주는 친구는 자바 컨테이너라고 함(Spring) > Spring 컨테이너 : 객체화를 담당
	(컨테이너란 객체화를 담당하는 무언가)

*(Spring) 컨테이너가 POJO(일반 자바 객체)를 객체화하는 순서
리스너 --> 톰캣시작
필터 --> 톰캣시작, *.do할 때마다 doFilter() 처럼
1) 설정정보를 필요로 함
	xxx.xml : 환경설정에 대한 파일
	web.xml : 서블릿 컨테이너(톰캣, 웹 서버)에게 설정을 알려주는 파일
		ex) encFilter할 때 인코딩 정보를 web.xml 에 저장
	pom.xml : Maven Dependencies 라이브러리, 패키지를 관리해주는 설정
		스프링 컨테이너에게 설정을 알려주고 작업을 수행해야함
		❤❤❤ 100% 완료될 때까지 대기 (띄어쓰기 조차도 하면 안됨)
2) xxx.xml이 로딩
3) 설정파일에 등록해둔 요청이 수행된다면,
4) 설정해두었던대로 객체화를 진행
5) 해당 객체의 메서드도 호출

*정리
이전에는 일반 자바 객체들을 개발자가 만들었고 그래서 결합도가 높았는데
스프링에서 가져가서 결합도를 낮춰준다는 것이 제어의 역행
그렇게 new를 가져갔기 때문에 언제 new를 해줘야하는지 명시 해줘야 한다는 것이 의존관계(디펜던시)
를 xml이 해줌 xml이란 환경설정 파일을 의미 잘만들어두었다면 그것을 로딩하고
설정해둔 상황이 수행되면 그때 객체화 진행하고 메서드 호출

*AOP (Aspect Oriented Programming 관점지향 프로그래밍)
기존 OOP (객체지향 프로그래밍)
	한계 : 비슷한 로직의 코드가 여러번 등장하는 상황 발생
	ex) JDBUtil : AOP의 시작이라고 볼 수 있는 예시상황
CRUD(비즈니스 메서드, 핵심 로직)  + 횡단관심(공통 로직)
완전 분리한 공통 로직 코드들이 각각 클래스화 되어 있음 -> 응집도가 높아짐
어떤 핵심 로직에 대해 어떤 공통 로직을 수행해야하는 지에 대한 설정 정보가 필요함
역시 xml파일이 필요함

*정리
❤"IoC와 AOP를 지원하는 경량(POJO를 다를 수 있다는 의미)의 프레임워크"
Ioc란 제어의 역행 개발자로부터 무언가를 가져갔다는 뜻 무엇을 가져가? new를 가져감
대신 언제 불러야 하는지 언제 new를 해야하는지만 알려줘 의존관계만 알려줘
기존에 서블릿만 new를 했었는데 java도 new를 한다는 뜻
AOP 관점지향 프로그램이으로
JDBCUtil썼지만 그것도 코드에 들어갔었지? 쓰지마
대신 내가 어떤 공통 로직을 넣어야하는 지 알려줘
new 너네가 하지마 util 내가 부를게, new 내가 해줄게 crud공통로직 내가 해줄게
❤new를 대신 해주고 crud에 대해 공통로직을 알아서 호출해주는 일반 자바 객체 코드를 다루는 프레임

*설치방법
직접설치 : 너무 복잡하고 아무도 그렇게 안함
플러그인
boot이용

*설치결과
Spring Legacy Project
Spring MVC Project
com.kim.app

*임포트 하는법
파일 임포트 제네럴 existing project intop works 넥스트
위에가 파일 밑에가 집파일 
집파일에 강사님이 보내준 파일 넣기
피니쉬

*세팅
1. 프로젝트 우클릭 > Properties > Maven > Project Facets
	Java 현재 버전으로 맞추기
	Dynamic Web Module 2.5
	Runtimes Apache Tomcat v9.0
2. 프로젝트 우클릭 > Properties  > Java Build Path > Server Runtime [Apache Tomcat v9.0] 있는지 확인
3. META-INF 삭제
4. webapp > web.xml 중간내용 다 삭제
5. webapp > WEB-INF > spring, view 삭제
6. pom.xml > java버전 맞추기, 4.2.4.RELEASE

----------

유지보수에 용이한 코드들은 경험해보지 않으면 획득하기 어렵다!

*코드의 결합도를 낮추는 방법
1) 인터페이스
	"설계"단계가 매우 중요
	객체지향의 특징 중에서 "다형성"을 활용한 것 : 오버라이딩
	ex. FC컨트롤러에서 액션 인터페이스를 만들어 사용하는 것
	ex. DAO의 CRUD 메서드 인자를 VO로 하자고 약속하는 것
2) 디자인 패턴 : 팩토리(Factory) 패턴
당연히 MVC써도 유지보수 용이 but 한가지 더 ! 실제 스프링에서는 팩토리 패턴이 많이 활용됨 > 이해하는데 도움이 될 것
	Factory에게 객체를 요청해서, 요청에 맞는 객체를 반환받아 사용하는 패턴
	Factory의 역할은 객체를 반환하는 것
	"Client(자바코드내)에서 직접적으로 new를 작성 xxx"
	== 결합도를 낮춤
사람들이 많이 사용하는 로직 객체를 Bean이라 함
무엇을 달라 할지 모르기 때문에 아웃풋은 항상 최상위 Object

Phone phone = new ApplePhone();
	BeanFactory bf = new BeanFactory();
	Phone phone = (Phone)bf.getBean("apple"); 
>Phone phone = (Phone)bf.getBean("args[0]");
Run > Run Configurations > Arguments > Program arguments
여기에 뭐라고 입력하는 지에 따라 소스코드를 건들지 않아도 동작이 달라짐

----------

*
설정파일은 *.xml
src/main/resources > Spring Bean Configuration File > applicationContext.xml
최상위 클래스는 beans
bean이 여러개 들어감
bean == new
객체를 생성해라
1 bean 태그 - 1 new 코드
<bean class="test.ApplePhone" id="apple" />
	1. 무엇을 new 할 것인지
	2. 뭐라고 부를 것인지

*
기존의 app.xml은 서블릿 한정, 그래서 톰캣을 서블릿 컨테이너라고 부름
그러나 지금부터는 스프링 컨테이너 일반 자바도 할 수 있음 그럴 땐 xml파일이 필요함

*정리
스프링 컨테이너(일반 자바 컨테이너)로 POJO를 객체화 해보자!
new 사용 xxx
applicationContext.xml 설정파일을 통해 객체관리함

*추상클래스는 객체화 xxx
일반적으로 자바 어플리이션에서 쓸 수 있는 친구 하나
웹에서 쓸 수 있는 친구 하나
s자 - 스프링 컨테이너의 관리 하에 있다

*동작 순서 ❤
1) Client가 스프링설정파일(applicationContext.xml)을 로딩
2) 로딩된 설정파일을 바탕으로 컨테이너(스프링 컨테이너) 구동됨
3) 컨테이너는 자신에게 등록된 객체들을 객체화함
4) 이때, ApplePhone의 기본생성자가 호출됨
5) 사용자들은 factory에 등록된 객체들을 요청
	== Look up
6) Look up한 객체들을 사용
beanfactory역할을 spring프레임워크가 함

*applicationContext.xml
== IoC 설정파일
== 의존관계를 명시해둔 설정파일

*bean태그에 달 수 있는 속성
init-method=""
	초기화
destroy-method=""
	해제
lazy-init="true"
	false가 디폴트 값
	켜놓으면 지연로딩
	스프링컨테이너는 기본적으로
		pre-loading 방식을 사용
		시작될 때 생성되어 메모리 차지하고 있다가 호출되면 사용
		지연로딩 시키고 싶으면 딜레이 로딩
		lazy-init 방식으로 변경시 사용자가 look up하면 그때 객체화가 진행됨

❤ 개발론에 관련된 디자인패턴 3가지 설명해보세요.
MVC 디자인 패턴 / 팩토리 패턴 / 싱글론 패턴
				-->> 한번 잘 만들어 놓은 객체를
					N번 호출하여 사용하는 것
					== 싱글톤 패턴을 유지하는 방식
scope="singleton"
scope="prototype"
❤ 최초로 new 라는 코드를 작성하는 개발자가 책임지고 싱글톤을 유지해야했었음!
❤ 스프링 프레임워크에서는 싱글톤을 유지시켜줌!
	어 이 객체 있던객첸데 갖다써야징 ㅋㅋ

*전체정리
init속성으로 각각 메모리 생성, 해제할때 메서드 연결 
기본값으로 pre-loading 지연로딩 하고싶으면 lazy-init
scope속성 prototype하면 singleton 깰 수 있음

----------

*전체정리
IoC와 AOP를 지원하는 경량의 프레임워크
제어의 역행 즉 뉴를 컨테이너가 대신 해줄 수 있는 프레임워크
에이오피 관점지향프로그래밍을 지원해줄 수 있는 프레임
근데 뭘 다루는? 서블릿 뿐 아니라 일반 자바도 다룰 수 있는
ex)핸드폰예제
구동 순서! 순서 중요합니다 왜 중요하냐면 나중에 뭘 하다보면 잘 안될거에요
그러면 그때 내가 여기서 막혔는데 이 전작업이 문제여서 막힌거겠죠?
근데 자꾸 이 다음거만 봐요 그래서 이 구동 방법의 순서 정확히 알고있어야한다
결합도 낮추는 코딩
엄청 중요한건데
일반적으로 인터페이스를 설정해 활용
팩토리 패턴도 사용
jsp때썼ㄷ너mvc
스프링 팩토리
라스트 싱글톤패턴
싱글톤패턴이란 객체를 한번 생성하게 되면 이 객체를 끝까지 사용한다는 개념
이 객체의 스코프 관리가 핵심 근데 이거 내가 안해요
누가해준다? 스프링 프레임워크가 해준다
짱 좋은 프레임워크다

*숙제

리모콘    TV
	AIR
--> 사용자가 어떤 리모콘을 호출했냐에 따라
ON -> TV ON / 히터 ON
UP -> TV 소리++ / 히터 온도 ++

이런식으로 다른 아웃풋이 나올 수 있도록 전체 구조 작성하기
1. 코드를 변경하지 않아도, 사용자가 어떤 리모콘을 요청했느냐(Look up)에 따라 콘솔화면이 달라지는 모습
2. new가 소스코드 내에 등장 xxx
3. 결합도가 충분히 낮은 상태의 코드인가?


</div>
</details>
<details>
<summary>0207</summary>
<div markdown="1">       

다형성을 활용하기 위해 인터페이스를 사용하였다.

----------

❤ 의존성 주입 Dependency Injection DI ❤

멤버변수인 watch에게 객체를 부여해야함
언제? ApplePhone 객체를 생성할 때!
== 정보 주입 == 멤버변수 정보 값을 주입 == DI
정보를 주는 행동 - 주입
이 정보가 멤버변수 - 의존성
	: 멤버변수는 본 객체에 대해 의존성을 갖고 있다!
이러한 객체간의 의존관계를 그린 그림 == 클래스 다이어그램

멤버변수의 값을 초기화해주는 역할 담당자
1) 생성자
	생성자 인젝션
2) setter
	setter 인젝션

생성자 인젝션이란 생성자에 인자로 주입할 객체값을 받아오는 것
	생성자에 인자로 명시되어있는 로직이 있다면 필수라서 넣어놓은 것

설정파일.xml에서는 순서 상관 없음

수행순서 강조하는 이유
a의 b기능이 안됩니다
a때문에 찾아오는데 확인해보니 b만들다가 문제
이전 단계가 안정적으로 실행되어야 이후 단계가 실행되는데 로그는 이후에 찍힐 수 있다

생성자 시작, 끝
메서드 시작, 끝
촘촘하게 로그 달아놓기!

===>> 스프링 컨테이너는 자동으로 의존성을 관리할 수 있구나!

art : 인자
property : 객체 속성 멤버변수

생성자 주입은 인자로 들어올 그러니까 아규먼트로 쓸 객체가 먼저 생성되는 반면,
세터 주입은 본 객체가 먼저 만들어지고 그다음에 세터로 만들어질 객채가 나중에 만들어짐
이러한 이유 때문에 사람들이 일반적으로 세터주입을 더 많이 보편적으로 쓰는 편
세터주입에 실패했을 경우 trycatch를 통해 본객체는 만들어지고 다음으로 넘어갈 수 있음
하지만 생성자주입은 본객체조차 만들어지지 않기 때문에 
생성자주입
멤버변수 먼저 그다음 본객체
세터주입
본객체 먼저 그다음 세터

의존성 주입 
스프링프레임워크를 사용하면 일반자바에대해
메서드 호출 해줄 뿐만 아니라 의존성도 관리해줄 수 있구나 ioc를 관리해주는 모습

생성자는 기본생성자 하나 그대로 유지하면서
세터를 두개 만들어냈어요 
멤버변수가 두개라서 세터도 두개 만들어 놓은 것입니다
나 세터 주입할거야 라고 프로퍼티 태그를 통해 말할 수 있습니다
로그를 보면
기본생성자 먼저 불리고 나서 세터 주입 되는 애들이 만들어지는 모습 확인해주시면 됩니다.

컬렉션인 경우 태그바디에 컬렉션 정보를 넣어주면 됩니다.

멤버변수가 객체거나 인트나 스트링 혹은 컬렉션일 때
스프링 컨테이너가 걔네들을 new해서 매칭해주는, 주입해주는, 넣어주는 작업을 의존성주입이라하고
이를통해 ioc를 지원해준다.
주입방법은 생성자주입과 세터주입이 있는데
생성자 주입할 때는 넣어줄 객체가 먼저 생성되고
세터 주입할 때는 넣을 객체가 나중에 생성된다는 특징이 있다.

----------

[과제]

Model 클래스
View 클래스
Controller 클래스

하나씩 만들어서
오늘 예제 
MVC 분리해서 작업

단, VO는 쓰지마시고, String으로 쓰세요! 어려우니까~

이 작업은 MVC, DI에 대한 이해가 필요합니다.





</div>
</details>
<details>
<summary>0208</summary>
<div markdown="1">       

1. factory 객체 생성 시점
factory 객체는 자바에서 형식상 스프링 컨테이너를 담당하고 있음
스프링 컨테이너를 구동시키기 위해 스프링 설정파일(*.xml)이 필요(로드)
					언제나 설정파일의 확장자명은 xml
스프링 컨테이너의 주 역할 : 
	1) 자바(POJO / Ctrl, Model, View) 객체 생성 및 관리
		컨테이너 : 객체 생성 및 관리
			서블릿 컨테이너는 서블릿 객체를 생성 및 관리
			톰캣		FrontController
					new FrontController한 적 없는데도 쓸 수 있었음
	2) DI(의존성 주입)
		객체를 생성할 때에 필요로 하는 멤버변수가 있다면
		해당 멤버변수에게 객체 주입을 해줌
		1) 생성자 주입
		2) setter 주입
객체들을 생성 및 관리해주기 때문에, 가장 먼저 호출되어야 함
2. 사용자가 필요로 하는 객체(Ctrl)를 Look up
app이라는 객체가 존재
property 세터주입
ref 객체
ex) view라는 이름의 객체가 필요
	태그바디 x (/로끝남) : DI x
	constructor-arg x : 기본생성자 사용
*
bean 태그바디가 닫혀있다면 >> DI x, 기본생성자 사용
property를 사용한다면 >> setter주입
constructor-arg를 사용한다면 >> 생성자 주입
주입 시 ref를 사용한다면 >> 객체 주입
주입 시 value를 사용한다면 >> 객체 외의 것 주입(int, String, ...)
*
3. Spring에서는 "설정"이 중요!
.xml 설정파일을 보고
DI의 유무
생성자 주입 vs setter 주입 

----------

Spring Starter Project << 부트 쓸 때 쓸거임
Spring legacy Project << 현재 쓰고 있는 것, 구조를 이해하려고, 실무에선 거의 안쓰임
프로젝트 만들 때 우측 하단 움직이고 있을 때 건드리면 깨질 수도 있음!

Project Exploer가 맞는지 확인
log4j.xml을 제외한 파일 제거 / META-INFO 제거
실수로 메인이 아니라 테스트 패키지로 가서 사용하는 경우가 있는데 사용 안할거니 건들 ㄴㄴ
웹앱 > 웹인프 > 스프링 뷰 삭제, web.xml 루트 엘리먼트인 웹앱만 남겨두고 제거
프로젝트 속성 자바 버전 11
런타임 9
폼xml 자바 버전 11 4.2.4

Spring Bean Con비네이션 파일 >> application.xml

기본생성자 > 초기화 0 ? > 의존주입안해도되나?

----------

>>>어노테이션 설정<<<

과거 설정파일을 .xml에 저장하여 관리했었음
.xml파일이 길어질수록 코더 입장에서는 분석하기 어려워짐
.xml파일에 대한 분석을 .java코드와 함께 해야함
 -> 설정내용을 .java 코드에 바로 적용할 수 있도록 해주는 @
 => 과도해지는 .xml 설정파일의 내용을 줄일 수 있게 되고,
	.java 코드와 함께 바로 설정 내용을 확인할 수 있게 됨

context넣으면 얘가 제공하는 태그 쓸 수 있음

❤ component-scan 객체 스캔
component 컴포넌트 == 모듈, 기능 단위, 플러그인, ...
하나의 메인 기능을 담당하고 있는 객체
scan : 객체화 되어야 하는 객체를 스캔
누가? 스프링 컨테이너가!

context라는 애가 component-scan이라는 것을 가지고 있음
component-scan이란 하나의 메인 기능을 담당하고 있는 객체가 객체화 되어야 하는가?를 스프링컨테이너가 스캔하는것

컴포넌트 스캔범위를 test로 하면 tes패키지에서만 실행됨
@Component
== new
== <bea>
과도한 xml 방지효과

----------

어노테이션으로도 의존성 주입(생성자, 세터)을 할 수 있다
임플리먼츠 했기 때문에 폰이 가지고 있는 네가지 메서드와 의존관계를 갖고있는 멤버변수 하나로 이루어짐
xml이였으면 생성자주입 혹은 세터주입을 했어야 했는데
어노테이션으로는 @Autowired만 걸어주면 끝난다
(DI해줌으로써 IoC지원)

BeanCreationException : Injection of autowired
뭔가 주입할 때 문제가 생겼다

메모리에 동일한 타입의 객체가 2개 이상이면 에러 발생!

클래스를 명시하면 결합도 높아지고 다형성이 깨지기 때문에 @Qualifier을 사용한다

@Component <bean> new
@Autowired DI
@Qualifier("객체명")

xml @

----------

사용자가 console창에
apple 이라고 입력하면
applePhone,
kiwi 라고 입력하면
KiwiPhone을 Look up 하여 제공
단, 잘못된 입력은 '해당객체가 없습니다...'
조건 1) applePhone 은 appleWatch를 사용하고
	kiwiPhone은 kiwiWatch를 사용합니다
조건 2) apple은 객체관리가 .xml로 이루어지고
	kiwi는 @으로 이루어집니다.
조건 3) apple은 DI를 생성자 주입방식을 사용합니다.

Model, View, Controller 이 예제를
@ 방식으로 DI 하여 구현해주세요!



</div>
</details>
<details>
<summary>0209</summary>
<div markdown="1">       

@Component()
@Autowired
@Qualifier()

진도 대신 설정

마이에스큐엘은 계정간 공간이 따로있는 느낌

-----------

MVC 디자인 패턴 + 비즈니스 레이어

프로젝트이름.비즈니스레이어에대한설명.다루는데이터멤버데이터

컨트롤러가 뷰로부터 받은 데이터를 모델한테 전달하지 않습니까?
예를들면 뷰가 사과 검색했어 라고 하면 서치 컨텐트에 사과를 넣어서 그 브이오를 디에이오에 전달하는 느낌이죠
근데? dao와 ctrl가 기존에는 직접적으로 연결되어있었음
컨트롤러가 액션 클래스 내부에 디에이오를 매번 뉴 해서 사용해왔음
그런데 스프링에서는 디에이오와 컨트롤러는 직접적으로 연결 x
왜? 결합도가 높아지니까
그래서 디에이오를 대신 사용해줄 무언가가 필요하게 되었고
그 역할을 담당하는게 비즈니스 레이어

Spring 프레임워크에서는 Controller가 직접적으로 DAO를 이용하지 않음
	왜? 결합도가 높아지니까
대신 DAO를 사용해줄 레이어를 하나 추가하는데 
	이 레이어를 "비즈니스 레이어"라고 부름

class Controller{
	public void method(){
		new DAO();
	}
}

class Controller{
	public void method(){
		비즈니스 레이어야, 너가 가진 DAO를 수행시켜줘 ~!
	}
}

비즈니스 레이어가 Phone, DAO가 Watch
비즈니스 레이어에서 사용할 메서드명과 DAO의 메서드명을 일치시키는 것이 보편적!

가독성과 메모리관리 성능증가
Service


DAO를 워치처럼 사용하겠다
폰 워치 메서드명 일치시켜줌

----------

스프링 프레임워크에는 전체 프로젝트에 대한 설정파일인 pom.xml가 있어요.
프로젝트에 적용되는 .jar들을 관리하는 파일입니다.
.jar를 직접 연결이 아니라 디펜던시스 안 디펜던시 태그 안에 넣으면
알아서 로딩하여 관리해줍니다.
파일이 없어도 된다는 소리!

.jar가 잘들어갔는지 확인하는 방법은
Maven Dependencies를 눌러보면 됩니다.
잘 들어와있지 않다면 업데이트를 강제해주면 되는데
메이븐 > 업데이트프로젝트 > 강제업데이트 체크 해주면 됩니다.
(우측하단 상태바가 백프로가 될 때까진 절대 건드리지 않기)

----------

>>> AOP <<<

유지보수 용이한 코드를 작성하는 것
1) 낮은 결합도
	IoC(제어의 역행)를 지원하는 스프링 프레임워크
	new를 대신해주고, DI(의존성 주입)를 대신해주는 것
	❤ 스프링 컨테이너는 팩토리 패턴을 활용하는구나
2) 높은 응집도
	AOP를 지원하는 스프링 프레임워크
	"기능별로 클래스를 묶어서 관리한다."
		인증, 로그, 보안, 트랜잭션과 같은 공통로직! 횡단관심을 따로 빼서 관리한다
	CRUD 뭘 하던 어떤 비즈니스 메서드를 돌리더라도 한번 호출되는 로그
얘로 된 주어가 생겼기 때문에 얘가 메서드를 수행하는 주체가 되었기 때문에 의존관계가 생겼고 그걸 코드안에 고스란히 쓰고 있기 때문에 결합도가 너무 높다
그래서 어떻게한다? 멤버변수로 뺀다

OOP의 한계 - 메서드명
멤버변수마냥 있는게 문제

스프링아!! 비즈니스메서드 하기 전에 횡단관심 호출해줘!!!!!!!

에스펙트제이
에이오피의 에이
		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjrt</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>	
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjweaver</artifactId>
			<version>1.8.8</version>
		</dependency>	

❤ AOP 설명순서
1) LogAdvice를 BoardWerviceImpl에서 사용
2) 그런데, LogAdvice를 업데이트하게됨
3) 업데이트된 LogAdvice2를 사용하니
4) 메서드명도 함께 업데이트되어서 직접 하나하나 코드를 수정하게됨...
	>> 엄청 손해 (OOP의 한계)
5) 스프링 컨테이너야, 너 AOP할 줄 알지?
	앞으로 비즈니스 메서드(CRUD, 핵심관심, 핵심로직)를 수행하기 전에
	공통로직(횡단관심)인 LogAdvice를 실행시켜줘~ 라고 설정을 해줄 예정!
비즈니스 메서드 : 핵심관심
공통로직 : 횡단관심 (ex. 로그, 트랜잭션, 인증, 보안, ... 뭘 해도 공통으로 하는 애들 Util류)

namespaces : aop~

AOP 용어
- Advice : 횡단 관심, 공통 로직
- pointcut : 핵심 관심, 핵심 로직, CRUD, 비즈니스 메서드 중에서 횡단 관심과 연결되는 메서드(로직)
	ex) 계좌이체를 할 때 반드시 보안처리를 해야하는 상황
	보안 횡단관심의 포인트컷은 계좌이체 메서드(로직)
- aspect 관점 : 기능지향적인 프로그래밍
	advice와 pointcut의 결합

여기가 반환이고 여기가 함수명이고 여기가 인자자리거든요
반환자리에 별 붙였잖아요 이거 아무런 리턴타입이나 상관없다는 뜻 
	셀렉 올 할 때쓰는 별 맞아요
아무런 반환타입이나 상관 없고
점 두개 찍었죠 인자 개수 상관없다는 뜻입니다
여기 경로 작성할건데 제 비즈니스 메서드라
com.sprnig.biz 하위에있는 impl로 끝나요

이런 핵심관심에 대해 이런 횡단관심을 수행시켜줘
언제? 비포에

포인트컷 : 핵심관심
어드바이스 : 횡단관심
에스팩트 : 결합 그자체


</div>
</details>
  <details>
<summary>0210</summary>
<div markdown="1">       

컨트롤러에서 익스큐트 즉, 액션류의 익스큐트 실행할 때
매번 뉴를 하게 되면

코드 결합도가 너무 높음
싱글톤 패턴 유지가 안됨

비즈니스레이어에 해당하는 클래스 = 서비스

제한할 수 있는 인터페이스 하나와
그것을 구현한 임플리클래스
> 비즈니스 레이어를 사용할 수 있는 사전준비 끝!

높은 응집도를 위해
AOP를 지원해준다

공통 로직 필요 > 어드바이스

유틸마냥 로그어드바이스를 직접사용하게 되면 뉴 코드
의존주입으로 최대한 뉴코드를 없앤다 해도 
업데이트에의한 메서드명 변경으로 인해
유지보수 불리

JDBCUtil도 공통로직
Connect메서드에 메서드명 변경하여 업데이트 하게 되면
공통로직을 사용하게 되고 있는 애들 모두 문제를 겪게됨

응집도를 높이기 위해 가장 처음 배운 유틸클래스
AOP없이 사용하다보니 
메서드명 변경했을 때 연쇄적으로 문제 발생
> OOP의 한계(문제점이 아니라 그냥 특성 ^^)

Util또한 AOP로 바꿔서 사용하기

-----------

실습풀이
횡단관심과 결함(aspect)들 변경

----------

AOP용어

❤ joinpoint (조인포인트)
	포인트컷 후보
	모든 비즈니스 메서드(CRUD, 핵심관심, 핵심로직)을 의미함
❤ pointcut (포인트컷)
	핵심관심
	핵심로직
	CRUD
	비즈니스 메서드
		중에서, 횡단관심과 연결되는 메서드(로직)
> 조인포인트 안에서 포인트컷을 고른다!

수행종료후
반환이후
에러발생하면 발생 이후
aroud 전후
전

aop는 결합시점도 정해줄 수있따

❤ weaving을 처리하는 친구 weaver
aop를 사용할 때 weaving처리가 반드시 있어야 한다
weaving이란 포인트컷을 수행할 때에 설정된 어드바이스를 주어진 동작시점에 호출하는 과정 그 자체를 의미함

weaving은 weaver가 처리하는 작업을 의미
weaver가 없으면 aop가 안됨

weaving처리 완료되었습니다!

Spring에만 있는 말은 아님
	컴파일, 메모리 로딩(적재) 등
Spring에서는 실행 시에만 위빙을 처리함! --> 런타임 위빙 방식을 지원함

❤ advisor(어드바이저)
aop컨피그에는 설정할 수 있는 태그가 3가지
포인트컷, 에스펙트 < 보통 이렇게 쓰는데
일부 설정은 어드바이저를 쓸 수 밖에 없는 경우가 있음(특이)
어드바이저 역시 에스펙트의 한 종류다
(advice+pointcut의 결합을 의미하는 단어)

----------

다른거 어떻게 쓰나요? 알려줄게~

예외발생하지 않으면 동작 x 일부러 예외를 만듬

수행종료후
반환이후
에러발생하면 발생 이후
aroud 전후
전

AROUND
매커니즘이 다른애들과 다름
인자 pjp 아웃풋 Object
비즈니스 메서드를 가로챌 수 있는 능력이 있음
전 후에 모두 개입 가능

----------

어드바이스 메서드를 보다 더 의미있게 구현하는 방법???

사용자가 편리하게 만들어주세요!
"편리하게" > "의미있게" : 
	횡단관심에서 현재 조합된 핵심관심이 무엇인지 파악할 수 있는 상황 
	> 조합된 핵심관심을 탈취할 수 있는(가로챌 수 있는) 인자가 필요ㅕ
	> JoinPoint jp
excepObj, obj와 같은 변수(인자)를 "바인드변수"라고 함
자동으로 바인딩 된다

실습문제)
비즈니스 메서드 중 select으로 시작하는 메서드가 있습니다.
이 메서드들의 특징은 output이 존재한다는 것인데요!
output이 만약 MemberVO라면, 회원을 조회했습니다.
혹은 로그인을 시도했습니다.
BoardVO라면, 글을 조회했습니다.
List라면, 전체조회했습니다.

+만약 MemberVO를 조회한 상황이라면
Admin인지, Member인지 파악하여 
Admin이 로그인한 상황이라면
관리자 모드 수행함이라는 로그 남겨주세요!

</div>
</details>
  <details>
<summary>여기를 눌러주세요</summary>
<div markdown="1">       

😎숨겨진 내용😎

</div>
</details>
